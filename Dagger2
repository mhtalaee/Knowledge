Dagger is a dependency injection framework, which makes it easier to manage the dependencies between the classes in our app.

Dagger1 was reflection-based, Dagger2 is based on annotation processing, so it does the magic at compile time.

Dagger2 Annotations:
@Inject
@Provides
@Module
@Component
@Singleton
@BindsInstance 

--------------------------------------------------------@Inject Annotation------------------------------------------------------------

@Inject Annotation:

Dagger creates instances of your application classes and satisfies their dependencies. 
It uses the @Inject (javax.inject.Inject annotation) to identify which constructors and fields it is interested in.
Actually @Inject is used to provide Constructor Injection in app.

--constructor example:

class Thermosiphon implements Pump {
  private final Heater heater;

  @Inject
  Thermosiphon(Heater heater) {
    this.heater = heater;
  }

  ...
}

--field example:

class CoffeeMaker {
  @Inject Heater heater;
  @Inject Pump pump;

  ...
}

--------------------------------------------------------@Provides Annotation------------------------------------------------------------

@Provides Annotation:

@Inject doesn’t work everywhere:

 -Interfaces can’t be constructed.
 
 -Third-party classes can’t be annotated.
 
 -Configurable objects must be configured!
 

For example, our dagger wants to create an instance of a class, but class isn't our so we can’t use @inject for this class constructor,
to solve this problem we write a fun that return an instance of this class and by @Provides we introduce this method to Dagger.

@Provides static Heater provideHeater() {
  return new ElectricHeater();
}

Another example: imagine our Dagger needs an instance of Context class, because Context is Android' class not our class, so it's impossible to
use @Inject annotation. we use @Provides annotation and introduce a method to get an instance of Context:

@Module
class ContextModule(private val appContext: Context) {
   @Provides
   fun appContext(): Context = appContext;
}


--It’s possible for @Provides methods to have dependencies of their own:

@Provides static Pump providePump(Thermosiphon pump) {
  return pump;
}

--------------------------------------------------------@Module Annotation------------------------------------------------------------

All @Provides methods must belong to a module (classes that have an @Module annotation)

@Module
class DripCoffeeModule {
  @Provides static Heater provideHeater() {
    return new ElectricHeater();
  }

  @Provides static Pump providePump(Thermosiphon pump) {
    return pump;
  }
}

--------------------------------------------------------@Component Annotation------------------------------------------------------------

@Component (ObjectGraph)

The @Inject and @Provides form a graph of objects.
Android Application base class should accesses that graph.
In Dagger2 this graph of objects is accessible via an @Component-annotated interface which has methods that have no arguments 
and return the desired type  and passing the module types to the modules parameter.
Dagger 2 then fully generates an implementation of that contract.

@Component(modules = DripCoffeeModule.class)
interface CoffeeShop {
  CoffeeMaker maker();
}

The implementation of this Interface has same name as the interface prefixed with Dagger (DaggerCoffeeShop).
Obtain an instance by invoking the following method on that implementation.

create method: When all dependencies can be constructed without the needing user to create any dependency instance:

	CoffeeShop coffeeShop = DaggerCoffeeShop.create();

builder method: When it's needed that user dependency instance

	CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
							.dripCoffeeModule(new DripCoffeeModule())
							.build();

--------------------------------------------------------@Singleton Annotation------------------------------------------------------------

@Singleton
Annotate an @Provides method or injectable class (class containing @Inject fields) with @Singleton. The graph will use a single instance 
of the value for all of its clients.

@Provides @Singleton static Heater provideHeater() {
  return new ElectricHeater();
}

@Singleton
class CoffeeMaker {
  ...
}


To declare that a component is associated with a given scope, simply apply the scope annotation to the component interface:

@Component(modules = DripCoffeeModule.class)
@Singleton
interface CoffeeShop {
  CoffeeMaker maker();
}

--------------------------------------------------------Dagger 2 specifications------------------------------------------------------------

--Compile-time Validation
The Dagger annotation processor is strict and will cause a compiler error if any bindings are invalid or incomplete

--Compile-time Code Generation
Dagger’s annotation processor generates source files with names like CoffeeMaker_Factory.java or CoffeeMaker_MembersInjector.java. 
These files are Dagger implementation details. You shouldn’t need to use them directly. 
The only generated types you should refer to in your code are the ones Prefixed with Dagger for your component like DaggerAppComponent.

--------------------------------------------------------@BindsInstance Annotation------------------------------------------------------------

You could use @BindsInstance and manually define your own @Component.Builder to do the exact same thing as @Provides and @Module annotations do.





