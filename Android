-Butter Knife library: To remove findViewById in code

  in kotlin it's enough to add following code to app gradle:
      androidExtensions{
            experimental = true
                }

-AndroidAnnotation: Open source framework for android development by Java

-Retrofit: Library to call webservices

-Add following to build.gradle when you want to use lambda:

compileOptions {

sourceCompatibility JavaVersion.VERSION_1_8

targetCompatibility JavaVersion.VERSION_1_8

}

-BaseActivity: Always create a BaseActivity class that extends AppCompatActivity.
  then App activities extends this BaseActivity useful for avoid repeatetive code like when you use Hawk

-BaseApplication: this class extends Application class. this class is called before activities.
  
-LeakCanary: A library to detect memory leaks in android
  
-Test

    1. BlackBox Test: by end user
    2. WhiteBox Test
        2.1. by developer
        2.2. Unit Test: just for testing plain java & kotlin codes (using junit library)
        2.3. Android Test (instrumented test)
        2.3. TDD (Test Driven Development)
        
-Architectures
      
      MVC
        View: Layout
        Controller: Activity
        Model: POJO
       
         
       
        Problem: causes big files
        
     
     MVP
       View: Activity - just includes android codes and codes that update view
       Presenter: includes business codes - master-mind of app
       Model: Data binding (WeService - DataBase - File)
        
          View & Model just inform Presenter about what happend and Presenter commands them what to do
          
          
     DI
        reduce classes dependency
          without DI, when in class B we have A a = new A, changing class A, causes error in class
          
          -Costructor dependency injection: 
          در این روش کلاس C بعنوان ورودی کلاس B، inject شده
          class B(val c : C) {
          }
          
          class A {
          val c = C()
          val b = B(c)
          }
          
          روش زیر روش DI نیست
          در این روش کلاس c در کلاس B ایجاد شده
          class B {
          val c= C()
          }
          
          class A {
          val b = B()
          }
          
          
         
